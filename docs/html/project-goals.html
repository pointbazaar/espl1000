<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">

  <title>SmallDragon - Project Goals</title>
  <meta name="description" content="SmallDragon Project Goals">
  <meta name="author" content="SmallDragon">

  <link rel="icon" href="../img/favicon.ico">
  
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous">
  <link rel="stylesheet" href="../css/style.css">

</head>

<body>

<div class="container">
	
	<div class="row nav-bg">
		<div class="col"><a href="../index.html">Home</a></div>
	</div>
	
	<h1 class="mb-3">SmallDragon Project Goals</h1>

	<h3> Design Decisions and Reasoning behind them</h3>

	<ul>
		<li> 
			<strong>hackable to the core </strong>
			<p>
			Make it your own. Everything in smalldragon
			is created with extendability and modularity in mind.
			The transpiler is composed of multiple small programs
			which can be used and modified independently.
			They communicate with easy-to-understand formats.
			</p>
		</li>
		<li>
			<strong>no macros</strong>
			<p>
				I made this decision to simplify the parsing of code
				and also because it makes code easier to read,
				as there is nothing that's 'hidden' away in some macro.
			</p>
		</li>
		<li>
			<strong>no effort for backwards compatibility </strong>
			<p>
				SmallDragon is a learning Project for me
				so anything might change whenever.
			</p>
		</li>
		<li>
			<strong>strict evaluation</strong>
			<p>
				I chose strict evaluation over lazy evaluation because
				lazy evaluation is harder to reason about as a programmer, in my opinion.
			</p>
		</li>
		<li>
			<strong>no user-defined prefix,infix or suffix operators</strong>
			<p>
				This greatly simplifies the parser.
			</p>
		</li>
		<li>
			<strong>not a self-hosting transpiler</strong>
			<p>
				This simplifies development as there are many tools
				available for C development.
			</p>
		</li>
		<li>
			<strong> no need to declare a namespace, methods and structs are top-level </strong>
			<p>
				In my opinion, it does not make sense to force unneccessary indentation
				on people. The name of the file is the namespace of a translation unit
				in smalldragon. structs and methods can be declared and defined directly,
				without needing a wrapper like a class or namespace construct.
				This also makes code easier to read without context.
			</p>
		</li>
		<li>
			<strong> no unneccessary nesting of syntactic constructs </strong>
			<p>
				There are no nested method definitions or nested structures 
				in smalldragon. Indentation is limited to the minimum necessary.
				I have personally never seen a case where it was necessary or
				'better' in any way to declare a nested function or anything like that.
			</p>
		</li>
		<li> 
			<strong> simple syntax </strong>
			<p>
				SmallDragon provides the basic building blocks like loops and if-statements
				that are classics to most programming languages. Extra stuff like 
				annotations or bloated syntax is avoided whenever possible.
			</p>
		</li>
	</ul>

	<h3> Safety Goals </h3>

	<ul>
		<li>
			<strong>no null/NULL/undefined</strong>
			<p>
				Having 'NULL' makes it hard to understand code without 
				context and knowledge of the code around it.
				Good code should make sense on it's own.
				So it should be obvious when a variable might not contain anything.
				So NULL will not be implemented in smalldragon.
			</p>
		</li>
		<li>
			<strong>no global state</strong>
			<p>
				SmallDragon has no ability to declare any global variables.
				Everything is (currently) either inside a struct or method.
			</p>
		</li>
		<li>
			<strong>no uninitialized variables</strong>
			<p>
				This feature is not complete yet. 
				It would be desireable to let the transpiler figure
				out if a given variable can be proven to have been assigned to
				before usage. This should also be true for struct members.
			</p>
		</li>
		<li>
			<strong> dependently typed primitive variables </strong>
			<p>
				Properties of primitive variables should be 
				propagated throughout the code so we can use
				static assertions to safeguard our code against faulty 
				values at compile-time. This exciting feature is waiting 
				for a concept for implementation currently.
			</p>
		</li>
		<li>
			<strong> pure functions and impure methods explicit </strong>
			<p>
				A function declared pure should not contain calls to 
				impure methods. Purity of a subroutine should be 
				checked by the transpiler. 
			</p>
		</li>
	</ul>


</div>

</body>
</html>
