<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">

  <title>Project Goals</title>
  <meta name="description" content="Project Goals">
  <meta name="author" content="ESPL1000">

  <link rel="icon" href="../img/favicon.ico">
  
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous">
  <link rel="stylesheet" href="../css/style.css">

</head>

<body>

<div class="container-xl">
	
	<div class="row nav-bg">
		<div class="col">
			<a href="../index.html"><h1>Home</h1></a>
		</div>
		<div class="col-2">
			<a href="tac.html"><h1>next</h1></a>
		</div>
	</div>
	
	<h1 class="mb-3">ESPL1000 Project Goals</h1>

	<h3> Design Decisions and Reasoning behind them</h3>

	<ul>
		<li> 
			<strong>hackable to the core </strong>
			<p>
			Make it your own. Everything in ESPL1000
			is created with extendability and modularity in mind.
			The transpiler is composed of multiple small programs
			which can be used and modified independently.
			They communicate with easy-to-understand formats.
			</p>
		</li>
		<li>
			<strong>no macros</strong>
			<p>
				I made this decision to simplify the parsing of code
				and also because it makes code easier to read,
				as there is nothing that's 'hidden' away in some macro.
			</p>
		</li>
		<li>
			<strong>no effort for backwards compatibility </strong>
			<p>
				ESPL1000 is a learning Project for me
				so anything might change whenever.
			</p>
		</li>
		<li>
			<strong>strict evaluation</strong>
			<p>
				I chose strict evaluation over lazy evaluation because
				lazy evaluation is harder to reason about as a programmer, in my opinion.
			</p>
		</li>
		<li>
			<strong>no user-defined prefix,infix or suffix operators</strong>
			<p>
				This greatly simplifies the parser.
			</p>
		</li>
		<li>
			<strong>not a self-hosting transpiler</strong>
			<p>
				This simplifies development as there are many tools
				available for C development.
			</p>
		</li>
		<li>
			<strong> no need to declare a namespace, methods and structs are top-level </strong>
			<p>
				In my opinion, it does not make sense to force unneccessary indentation
				on people. The name of the file is the namespace of a translation unit
				in ESPL1000. structs and methods can be declared and defined directly,
				without needing a wrapper like a class or namespace construct.
				This also makes code easier to read without context.
			</p>
		</li>
		<li>
			<strong> no unneccessary nesting of syntactic constructs </strong>
			<p>
				There are no nested method definitions or nested structures 
				in ESPL1000. Indentation is limited to the minimum necessary.
				I have personally never seen a case where it was necessary or
				'better' in any way to declare a nested function or anything like that.
			</p>
		</li>
		<li> 
			<strong> simple syntax </strong>
			<p>
				ESPL1000 provides the basic building blocks like loops and if-statements
				that are classics to most programming languages. Extra stuff like 
				annotations or bloated syntax is avoided whenever possible.
			</p>
		</li>
	</ul>

	<h3> Safety Goals </h3>

	<ul>
		<li>
			<strong>no null/NULL/undefined</strong>
			<p>
				Having 'NULL' makes it hard to understand code without 
				context and knowledge of the code around it.
				Good code should make sense on it's own.
				So it should be obvious when a variable might not contain anything.
				So NULL will not be implemented in ESPL1000.
			</p>
		</li>
		<li>
			<strong>no global state</strong>
			<p>
				ESPL1000 has no ability to declare any global variables.
				Everything is (currently) either inside a struct or method.
			</p>
		</li>
		<li>
			<strong>no uninitialized variables</strong>
			<p>
				This feature is not complete yet. 
				It would be desireable to let the transpiler figure
				out if a given variable can be proven to have been assigned to
				before usage. This should also be true for struct members.
			</p>
		</li>
		<li>
			<strong> dependently typed primitive variables </strong>
			<p>
				Properties of primitive variables should be 
				propagated throughout the code so we can use
				static assertions to safeguard our code against faulty 
				values at compile-time. This exciting feature is waiting 
				for a concept for implementation currently.
			</p>
		</li>
		<li>
			<strong> pure functions and impure methods explicit </strong>
			<p>
				A function declared pure should not contain calls to 
				impure methods. Purity of a subroutine should be 
				checked by the transpiler. 
			</p>
		</li>
	</ul>


</div>

</body>
</html>
